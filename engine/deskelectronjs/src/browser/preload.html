<script defer>
  /**
   * Copyright (c) 2024   Loh Wah Kiang
   *
   * openGauss is licensed under Mulan PSL v2.
   * You can use this software according to the terms and conditions of the Mulan PSL v2.
   * You may obtain a copy of Mulan PSL v2 at:
   *
   *          http://license.coscl.org.cn/MulanPSL2
   *
   * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
   * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
   * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
   * See the Mulan PSL v2 for more details.
   * -------------------------------------------------------------------------
   */
  "use strict";

  var glib = {};

  const getNestedObject = (obj, dotSeparatedKeys) => {
    if (dotSeparatedKeys !== undefined && typeof dotSeparatedKeys !== "string")
      return undefined;
    if (typeof obj !== "undefined" && typeof dotSeparatedKeys === "string") {
      // split on ".", "[", "]", "'", """ and filter out empty elements
      const splitRegex = /[.\[\]'"]/g; // eslint-disable-line no-useless-escape
      const pathArr = dotSeparatedKeys
        .split(splitRegex)
        .filter((k) => k !== "");

      // eslint-disable-next-line no-param-reassign, no-confusing-arrow
      obj = pathArr.reduce(
        (o, key) => (o && o[key] !== "undefined" ? o[key] : undefined),
        obj
      );
    }
    return obj;
  };

  const datatype = (value) => {
    try {
      let output = typeof value;
      if (output == "string") {
        if (!isNaN(value)) output = "number";
      } else if (output == "object") {
        if (Array.isArray(value)) {
          output = "array";
        } else if (Object.keys(value).length > 0) {
          output = "object";
        }
      }
      return output;
    } catch (error) {
      return error;
    }
  };

  const pick_arrayofobj = (...args) => {
    let [arrobj, picker, rename] = args;
    let output = [];
    for (let [idx, obj] of Object.entries(arrobj)) {
      let data = {};

      picker.map((val) => {
        let dtype = datatype(val);

        if (dtype == "string") {
          let { [val]: reserve, ...rest } = obj;
          if (reserve !== undefined && reserve != null)
            data = { ...data, ...{ [val]: reserve } };
          output.push(data);
        } else if (dtype == "object") {
          let [keyname] = Object.keys(val);
          let { [keyname]: reserve, ...rest } = obj;

          if (rename) {
            let key = rename[idx];
            data = { ...data, ...{ [key]: reserve } };
          } else {
            data = { ...data, ...reserve };
          }

          if (output.length == 0) output.push({ [keyname]: data });
          else output[0][keyname] = { ...output[0][keyname], ...data };
        }
      });
    }
    return output;
  };

  const pick_arrayobj2list = (...args) => {
    let [arrobj, picker] = args;
    let output = {};
    for (let obj of arrobj) {
      picker.map((val) => {
        const { [val]: reserve, ...rest } = obj;
        if (reserve !== undefined && reserve != null) {
          if (!output[val]) output[val] = [];
          output[val].push(reserve);
        }
      });
    }
    return output;
  };

  const omit = (...args) => {
    let [object, keys] = args;
    let rtn = object;
    keys.split(" ").map((val) => {
      const { [val]: omitted, ...rest } = rtn;
      rtn = rest;
    });
    return rtn;
  };

  const objpick = (...args) => {
    let [object, keys] = args;
    let rtn = {};
    keys.split(" ").map((key) => (rtn[key] = object[key]));
    return rtn;
  };

  const arr_selected = (...args) => {
    const [source, compare] = args;
    let output = { code: 0, msg: "", data: null };
    try {
      output.data = source.filter(function (val) {
        return compare.indexOf(val) != -1;
      });
    } catch (error) {
      output = errhandler(error);
    } finally {
      return output;
    }
  };

  const arr_diffidx = (...args) => {
    const [source, compare, format = 1] = args;
    let output = { code: 0, msg: "", data: null };
    try {
      if (format == 2)
        output.data = {
          source: { index: [], value: [] },
          compare: { index: [], value: [] },
        };
      else output.data = [];
      let diff = source
        .concat(compare)
        .filter((val) => !(source.includes(val) && compare.includes(val)));
      if (diff.length > 0) {
        diff.forEach((value) => {
          let result;
          let pos_source = source.findIndex((element) => element == value);
          let pos_compare = compare.findIndex((element) => element == value);
          if (pos_source > -1) {
            if (format == 2) {
              output.data.source.index.push(pos_source);
              output.data.source.value.push(value);
            } else result = { from: "source", index: pos_source, value: value };
          } else if (pos_compare > -1) {
            if (format == 2) {
              output.data.compare.index.push(pos_compare);
              output.data.compare.value.push(value);
            } else
              result = {
                from: "compare",
                index: pos_compare,
                value: value,
              };
          }
          if (result && format != 2) output.data.push(result);
        });
      }
    } catch (error) {
      output = errhandler(error);
    } finally {
      return output;
    }
  };

  const concatobj = (...args) => {
    const [type, param1, param2] = args;
    let output;
    let data1, data2;
    try {
      const mergedata = (type, arg1, arg2) => {
        let output;
        switch (type) {
          case "array":
            output = arg1.concat(arg2);
            break;
          case "object":
            output = mergeDeep(arg1, arg2);
            break;
        }
        return output;
      };

      let reftype = datatype(type);
      let refdata1 = datatype(param1);
      let refdata2 = datatype(param2);

      data1 = param1;
      data2 = param2;
      if (refdata1 == "undefined") data1 = type;
      if (refdata2 == "undefined") data2 = type;

      output = mergedata(reftype, data1, data2);
    } catch (error) {
      output = errhandler(error);
    } finally {
      return output;
    }
  };

  const sanbox = async (...args) => {
    let [fn, name, params] = args;
    try {
      let result = fn.apply(null, params);
      if (result instanceof Promise) {
        result = await result;
        if (result instanceof ReferenceError) throw result;
      } else if (result instanceof ReferenceError) throw result;
    } catch (error) {
      console.log("Error:", name, "---", error.toString());
    } finally {
      return;
    }
  };
  
  const serialize = async (...args) => {
    return new Promise(async (resolve) => {
      const [params, obj] = args;
      const [library, sys, cosetting] = obj;
      const { datatype, errhandler, getNestedObject, handler, sanbox } =
        library.utils;
      const { jptr } = sys;

      try {
        const { err, func: funcs, workflow, share } = params;
        let output = handler.dataformat;
        let temp = {},
          pool = {},
          fnerrs = [];

        err.map((fname) => {
          let fnerr = getNestedObject(funcs, fname);
          if (fnerr) fnerrs.push(fnerr);
        });
        for (let [idx, compval] of Object.entries(workflow)) {
          let { error, func, name, param, pull, push } = compval;
          let fn = getNestedObject(funcs, func);

          if (!fn) {
            output.code = -3;
            output.msg = `Process stop at (${name}).Current onging  step:${parseInt(idx) + 1
              }/${workflow.length}. `;
            break;
          } else {
            let queuertn, funcparams;
            if (pull.length == 0) funcparams = param;
            else {
              const getparams = (...args) => {
                let [value, cache_temp, cache_share] = args;
                let result;
                if (value.lastIndexOf(".") > -1) {
                  let location = value.replaceAll(".", "/");
                  let getpull_temp = jptr.get(cache_temp, location);
                  let getpull_share = jptr.get(cache_share, location);
                  if (getpull_temp) result = getpull_temp;
                  else if (getpull_share) result = getpull_share;
                }
                return result;
              };

              funcparams = [];
              for (let value of pull) {
                let dtype = datatype(value);
                switch (dtype) {
                  case "string":
                    let result = getparams(value, temp, share);
                    if (result) funcparams.push(result);
                    break;
                  case "array":
                    let arr_result = [];
                    for (let subval of value) {
                      let result = getparams(subval, temp, share);
                      if (result) arr_result.push(result);
                    }
                    funcparams.push(arr_result);
                    break;
                }
              }
              if (param.length > 0) funcparams = funcparams.concat(param);
            }

            queuertn = sanbox(fn, funcparams);
            if (queuertn instanceof Promise) queuertn = await queuertn;
            let { code, data, msg } = queuertn;
            if (code == 0) {
              push.map((value, id) => {
                let dataval = data[value];
                if (!dataval) dataval = data;
                if (value.lastIndexOf(".") > -1) {
                  let location = value.replaceAll(".", "/");
                  jptr.set(share, location, dataval);
                } else {
                  jptr.set(temp, `${name}/${value}`, dataval);
                }
              });
            } else {
              if (fnerrs.length > 0) {
                let fnerr = [];
                fnerrs.map((fn) => {
                  fnerr.push(fn.apply(null, [queuertn]));
                });
                await Promise.all(fnerr);
              } else if (error != "") {
                let fnerr = getNestedObject(funcs, error);
                fnerr.apply(null, [queuertn]);
              }
            }
          }
        }

        if (output.code == 0) {
          output.data = pool;
        }
        resolve(output);
      } catch (error) {
        resolve(errhandler(error));
      }
    });
  };

  const errhandler = (...args) => {
    let [error] = args;
    if (error.errno)
      return {
        code: error.errno,
        errno: error.errno,
        message: error.message,
        stack: error.stack,
        data: error,
      };
    else
      return {
        code: -1,
        errno: -1,
        message: error.message,
        stack: error.stack,
        data: error,
      };
  };

  glib = {
    utils: {
      sanbox: sanbox,
      getNestedObject: getNestedObject,
      datatype: datatype,
      pick_arrayofobj: pick_arrayofobj,
      pick_arrayobj2list: pick_arrayobj2list,
      omit: omit,
      objpick: objpick,
      arr_selected: arr_selected,
      arr_diffidx: arr_diffidx,
      concatobj: concatobj,
      serialize: serialize,
      errhandler: errhandler,
      get dataformat() {
        return Object.assign(
          {},
          {
            code: 0,
            msg: "",
            data: null,
          }
        );
      },
      get fmtseries() {
        return Object.assign(
          {},
          {
            err: [],
            func: {},
            share: {},
          }
        );
      },
      get wfwseries() {
        return Object.assign(
          {},
          {
            error: "",
            func: "",
            name: "",
            param: [],
            pull: [],
            push: [],
          }
        );
      },
    },
  };

  /**------------------ Private function--------------------------------------------*/
  const initialize = async (...args) => {
    let [param] = args;

    for (let [idx, val] of Object.entries(param)) {
      let func = getNestedObject(glib, idx);
      if (func) await sanbox(func, idx, val);
    }

    return;
  };

  const loadlib = async (...args) => {
    try {
      let [param] = args;
      for (let item of param) {
        let fn = item.split("/").pop().replace(".js", "");
        fn = fn.replace(".", "-");
        let { default: df, ...otherlib } = await import(item);
        if (Object.keys(otherlib).length > 0) glib[fn] = { ...df, ...otherlib };
        else glib[fn] = df;
      }
      return;
    } catch (error) {
      console.log(error);
    }
  };

  window.addEventListener("DOMContentLoaded", async () => {
    if (mjs) {
      if (mjs.lib.length > 0) await loadlib(mjs.lib);
      if (Object.keys(mjs.initialize).length > 0)
        await initialize(mjs.initialize);
    }
  });
</script>