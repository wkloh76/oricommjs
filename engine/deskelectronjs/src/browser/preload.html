<script defer>
  /**
   * Copyright (c) 2024   Loh Wah Kiang
   *
   * openGauss is licensed under Mulan PSL v2.
   * You can use this software according to the terms and conditions of the Mulan PSL v2.
   * You may obtain a copy of Mulan PSL v2 at:
   *
   *          http://license.coscl.org.cn/MulanPSL2
   *
   * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
   * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
   * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
   * See the Mulan PSL v2 for more details.
   * -------------------------------------------------------------------------
   */
  "use strict";

  var glib = {};

  const getNestedObject = (obj, dotSeparatedKeys) => {
    if (dotSeparatedKeys !== undefined && typeof dotSeparatedKeys !== "string")
      return undefined;
    if (typeof obj !== "undefined" && typeof dotSeparatedKeys === "string") {
      // split on ".", "[", "]", "'", """ and filter out empty elements
      const splitRegex = /[.\[\]'"]/g; // eslint-disable-line no-useless-escape
      const pathArr = dotSeparatedKeys
        .split(splitRegex)
        .filter((k) => k !== "");

      // eslint-disable-next-line no-param-reassign, no-confusing-arrow
      obj = pathArr.reduce(
        (o, key) => (o && o[key] !== "undefined" ? o[key] : undefined),
        obj
      );
    }
    return obj;
  };

  const datatype = (value) => {
    try {
      let output = typeof value;
      if (output == "string") {
        if (!isNaN(value)) output = "number";
      } else if (output == "object") {
        if (Array.isArray(value)) {
          output = "array";
        } else if (Object.keys(value).length > 0) {
          output = "object";
        }
      }
      return output;
    } catch (error) {
      return error;
    }
  };

  const pick_arrayofobj = (...args) => {
    let [arrobj, picker, rename] = args;
    let output = [];
    for (let [idx, obj] of Object.entries(arrobj)) {
      let data = {};

      picker.map((val) => {
        let dtype = datatype(val);

        if (dtype == "string") {
          let { [val]: reserve, ...rest } = obj;
          if (reserve !== undefined && reserve != null)
            data = { ...data, ...{ [val]: reserve } };
          output.push(data);
        } else if (dtype == "object") {
          let [keyname] = Object.keys(val);
          let { [keyname]: reserve, ...rest } = obj;

          if (rename) {
            let key = rename[idx];
            data = { ...data, ...{ [key]: reserve } };
          } else {
            data = { ...data, ...reserve };
          }

          if (output.length == 0) output.push({ [keyname]: data });
          else output[0][keyname] = { ...output[0][keyname], ...data };
        }
      });
    }
    return output;
  };

  const pick_arrayobj2list = (...args) => {
    let [arrobj, picker] = args;
    let output = {};
    for (let obj of arrobj) {
      picker.map((val) => {
        const { [val]: reserve, ...rest } = obj;
        if (reserve !== undefined && reserve != null) {
          if (!output[val]) output[val] = [];
          output[val].push(reserve);
        }
      });
    }
    return output;
  };

  const omit = (...args) => {
    let [object, keys] = args;
    let rtn = object;
    keys.split(" ").map((val) => {
      const { [val]: omitted, ...rest } = rtn;
      rtn = rest;
    });
    return rtn;
  };

  const objpick = (...args) => {
    let [object, keys] = args;
    let rtn = {};
    keys.split(" ").map((key) => (rtn[key] = object[key]));
    return rtn;
  };

  const arr_selected = (...args) => {
    const [source, compare] = args;
    let output = { code: 0, msg: "", data: null };
    try {
      output.data = source.filter(function (val) {
        return compare.indexOf(val) != -1;
      });
    } catch (error) {
      output = errhandler(error);
    } finally {
      return output;
    }
  };

  const arr_diffidx = (...args) => {
    const [source, compare, format = 1] = args;
    let output = { code: 0, msg: "", data: null };
    try {
      if (format == 2)
        output.data = {
          source: { index: [], value: [] },
          compare: { index: [], value: [] },
        };
      else output.data = [];
      let diff = source
        .concat(compare)
        .filter((val) => !(source.includes(val) && compare.includes(val)));
      if (diff.length > 0) {
        diff.forEach((value) => {
          let result;
          let pos_source = source.findIndex((element) => element == value);
          let pos_compare = compare.findIndex((element) => element == value);
          if (pos_source > -1) {
            if (format == 2) {
              output.data.source.index.push(pos_source);
              output.data.source.value.push(value);
            } else result = { from: "source", index: pos_source, value: value };
          } else if (pos_compare > -1) {
            if (format == 2) {
              output.data.compare.index.push(pos_compare);
              output.data.compare.value.push(value);
            } else
              result = {
                from: "compare",
                index: pos_compare,
                value: value,
              };
          }
          if (result && format != 2) output.data.push(result);
        });
      }
    } catch (error) {
      output = errhandler(error);
    } finally {
      return output;
    }
  };

  const concatobj = (...args) => {
    const [type, param1, param2] = args;
    let output;
    let data1, data2;
    try {
      let mergedata = (type, arg1, arg2) => {
        let output;
        switch (type) {
          case "array":
            output = arg1.concat(arg2);
            break;
          case "object":
            output = mergeDeep(arg1, arg2);
            break;
        }
        return output;
      };

      let reftype = datatype(type);
      let refdata1 = datatype(param1);
      let refdata2 = datatype(param2);

      data1 = param1;
      data2 = param2;
      if (refdata1 == "undefined") data1 = type;
      if (refdata2 == "undefined") data2 = type;

      output = mergedata(reftype, data1, data2);
    } catch (error) {
      output = errhandler(error);
    } finally {
      return output;
    }
  };

  const sanbox = async (...args) => {
    let [fn, name, params] = args;
    try {
      let result = fn.apply(null, params);
      if (result instanceof Promise) {
        result = await result;
        if (result instanceof ReferenceError) throw result;
      } else if (result instanceof ReferenceError) throw result;
    } catch (error) {
      console.log("Error:", name, "---", error.toString());
    } finally {
      return;
    }
  };

  glib = {
    utils: {
      sanbox: sanbox,
      getNestedObject: getNestedObject,
      datatype: datatype,
      pick_arrayofobj: pick_arrayofobj,
      pick_arrayobj2list: pick_arrayobj2list,
      omit: omit,
      objpick: objpick,
      arr_selected: arr_selected,
      arr_diffidx: arr_diffidx,
      concatobj: concatobj,
    },
  };

  /**------------------ Private function--------------------------------------------*/
  const initialize = async (...args) => {
    let [param] = args;

    for (let [idx, val] of Object.entries(param)) {
      let func = getNestedObject(glib, idx);
      if (func) await sanbox(func, idx, val);
    }

    return;
  };

  const loadlib = async (...args) => {
    try {
      let [param] = args;
      for (let item of param) {
        let fn = item.split("/").pop().replace(".js", "");
        fn = fn.replace(".", "-");
        let { default: df, ...otherlib } = await import(item);
        if (Object.keys(otherlib).length > 0) glib[fn] = { ...df, ...otherlib };
        else glib[fn] = df;
      }
      return;
    } catch (error) {
      console.log(error);
    }
  };

  window.addEventListener("DOMContentLoaded", async () => {
    if (mjs) {
      if (mjs.lib.length > 0) await loadlib(mjs.lib);
      if (Object.keys(mjs.initialize).length > 0)
        await initialize(mjs.initialize);
    }
  });
</script>
