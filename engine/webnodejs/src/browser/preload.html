<script defer>
  /**
   * Copyright (c) 2024   Loh Wah Kiang
   *
   * openGauss is licensed under Mulan PSL v2.
   * You can use this software according to the terms and conditions of the Mulan PSL v2.
   * You may obtain a copy of Mulan PSL v2 at:
   *
   *          http://license.coscl.org.cn/MulanPSL2
   *
   * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
   * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
   * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
   * See the Mulan PSL v2 for more details.
   * -------------------------------------------------------------------------
   */
  "use strict";

  var glib = {};
  var sysmodule = {}, kernel = {}

  const getNestedObject = (obj, dotSeparatedKeys) => {
    if (dotSeparatedKeys !== undefined && typeof dotSeparatedKeys !== "string")
      return undefined;
    if (typeof obj !== "undefined" && typeof dotSeparatedKeys === "string") {
      // split on ".", "[", "]", "'", """ and filter out empty elements
      const splitRegex = /[.\[\]'"]/g; // eslint-disable-line no-useless-escape
      const pathArr = dotSeparatedKeys
        .split(splitRegex)
        .filter((k) => k !== "");

      // eslint-disable-next-line no-param-reassign, no-confusing-arrow
      obj = pathArr.reduce(
        (o, key) => (o && o[key] !== "undefined" ? o[key] : undefined),
        obj
      );
    }
    return obj;
  };

  const datatype = (value) => {
    try {
      let output = typeof value;
      if (output == "string") {
        if (!isNaN(value)) output = "number";
      } else if (output == "object") {
        if (Array.isArray(value)) {
          output = "array";
        } else if (Object.keys(value).length > 0) {
          output = "object";
        }
      }
      return output;
    } catch (error) {
      return error;
    }
  };

  const pick_arrayofobj = (...args) => {
    let [arrobj, picker, rename] = args;
    let output = [];
    for (let [idx, obj] of Object.entries(arrobj)) {
      let data = {};

      picker.map((val) => {
        let dtype = datatype(val);

        if (dtype == "string") {
          let { [val]: reserve, ...rest } = obj;
          if (reserve !== undefined && reserve != null)
            data = { ...data, ...{ [val]: reserve } };
          output.push(data);
        } else if (dtype == "object") {
          let [keyname] = Object.keys(val);
          let { [keyname]: reserve, ...rest } = obj;

          if (rename) {
            let key = rename[idx];
            data = { ...data, ...{ [key]: reserve } };
          } else {
            data = { ...data, ...reserve };
          }

          if (output.length == 0) output.push({ [keyname]: data });
          else output[0][keyname] = { ...output[0][keyname], ...data };
        }
      });
    }
    return output;
  };

  const pick_arrayobj2list = (...args) => {
    let [arrobj, picker] = args;
    let output = {};
    for (let obj of arrobj) {
      picker.map((val) => {
        const { [val]: reserve, ...rest } = obj;
        if (reserve !== undefined && reserve != null) {
          if (!output[val]) output[val] = [];
          output[val].push(reserve);
        }
      });
    }
    return output;
  };

  const omit = (...args) => {
    let [object, keys] = args;
    let rtn = object;
    keys.split(" ").map((val) => {
      const { [val]: omitted, ...rest } = rtn;
      rtn = rest;
    });
    return rtn;
  };

  const objpick = (...args) => {
    let [object, keys] = args;
    let rtn = {};
    keys.split(" ").map((key) => (rtn[key] = object[key]));
    return rtn;
  };

  const arr_selected = (...args) => {
    const [source, compare] = args;
    let output = { code: 0, msg: "", data: null };
    try {
      output.data = source.filter(function (val) {
        return compare.indexOf(val) != -1;
      });
    } catch (error) {
      output = errhandler(error);
    } finally {
      return output;
    }
  };

  const arr_diffidx = (...args) => {
    const [source, compare, format = 1] = args;
    let output = { code: 0, msg: "", data: null };
    try {
      if (format == 2)
        output.data = {
          source: { index: [], value: [] },
          compare: { index: [], value: [] },
        };
      else output.data = [];
      let diff = source
        .concat(compare)
        .filter((val) => !(source.includes(val) && compare.includes(val)));
      if (diff.length > 0) {
        diff.forEach((value) => {
          let result;
          let pos_source = source.findIndex((element) => element == value);
          let pos_compare = compare.findIndex((element) => element == value);
          if (pos_source > -1) {
            if (format == 2) {
              output.data.source.index.push(pos_source);
              output.data.source.value.push(value);
            } else result = { from: "source", index: pos_source, value: value };
          } else if (pos_compare > -1) {
            if (format == 2) {
              output.data.compare.index.push(pos_compare);
              output.data.compare.value.push(value);
            } else
              result = {
                from: "compare",
                index: pos_compare,
                value: value,
              };
          }
          if (result && format != 2) output.data.push(result);
        });
      }
    } catch (error) {
      output = errhandler(error);
    } finally {
      return output;
    }
  };

  const concatobj = (...args) => {
    const [type, param1, param2] = args;
    let output;
    let data1, data2;
    try {
      const mergedata = (type, arg1, arg2) => {
        let output;
        switch (type) {
          case "array":
            output = arg1.concat(arg2);
            break;
          case "object":
            output = mergeDeep(arg1, arg2);
            break;
        }
        return output;
      };

      let reftype = datatype(type);
      let refdata1 = datatype(param1);
      let refdata2 = datatype(param2);

      data1 = param1;
      data2 = param2;
      if (refdata1 == "undefined") data1 = type;
      if (refdata2 == "undefined") data2 = type;

      output = mergedata(reftype, data1, data2);
    } catch (error) {
      output = errhandler(error);
    } finally {
      return output;
    }
  };

  const sanbox = async (...args) => {
    let [fn, params] = args;
    try {
      let result = fn.apply(null, params);
      if (result instanceof Promise) {
        result = await result;
        if (result instanceof ReferenceError) throw result;
      } else if (result instanceof ReferenceError) throw result;
      return result;
    } catch (error) {
      return errhandler(error);
    }
  };

  const serialize = async (...args) => {
    return new Promise(async (resolve) => {
      const [params, obj] = args;
      const [library, sys] = obj;
      const { datatype, errhandler, getNestedObject, handler, sanbox } =
        library.utils;
      const { jptr } = sys;

      try {
        const { err, func: funcs, workflow, share } = params;
        let output = handler.dataformat;
        let temp = {},
          pool = {},
          fnerrs = [];

        err.map((fname) => {
          let fnerr = getNestedObject(funcs, fname);
          if (fnerr) fnerrs.push(fnerr);
        });
        for (let [idx, compval] of Object.entries(workflow)) {
          let { error, func, name, param, pull, push } = {
            ...handler.wfwseries,
            ...compval,
          };

          for (let [kfunc, vfunc] of Object.entries(func.split(","))) {
            let fn = getNestedObject(funcs, vfunc);
            if (!fn) {
              output.code = -3;
              output.msg = `Process stop at (${name}).Current onging step is:${parseInt(idx) + 1
                }/${workflow.length}. `;
              break;
            } else {
              let queuertn,
                funcparams = [];
              if (pull[kfunc]) {
                if (pull[kfunc].length == 0) {
                  if (param[kfunc]) {
                    if (param[kfunc].length > 0) funcparams = param[kfunc];
                  }
                } else {
                  const getparams = (...args) => {
                    let [value, cache_temp, cache_share] = args;
                    let result;
                    if (value.lastIndexOf(".") > -1) {
                      let location = value.replaceAll(".", "/");
                      let getpull_temp = jptr.get(cache_temp, location);
                      let getpull_share = jptr.get(cache_share, location);
                      if (getpull_temp) result = getpull_temp;
                      else if (getpull_share) result = getpull_share;
                    }
                    return result;
                  };

                  let cache_pull = [];
                  for (let value of pull[kfunc]) {
                    let dtype = datatype(value);
                    switch (dtype) {
                      case "string":
                        let result = getparams(value, temp, share);
                        if (result) cache_pull.push(result);
                        break;
                      case "array":
                        let arr_result = [];
                        for (let subval of value) {
                          let result = getparams(subval, temp, share);
                          if (result) arr_result.push(result);
                        }
                        cache_pull.push(arr_result);
                        break;
                    }
                  }
                  if (!param[kfunc]) {
                    if (cache_pull.length > 0) funcparams = cache_pull;
                  } else {
                    if (cache_pull.length == 1) funcparams = cache_pull;
                    else if (cache_pull.length >= 1)
                      funcparams.push(cache_pull);
                    if (param[kfunc].length > 0) {
                      funcparams = funcparams.concat(param[kfunc]);
                    }
                  }
                }
              } else {
                if (param[kfunc]) {
                  if (param[kfunc].length > 0)
                    funcparams = funcparams.concat(param[kfunc]);
                }
              }

              queuertn = sanbox(fn, funcparams);
              if (queuertn instanceof Promise) queuertn = await queuertn;
              let { code, data, msg } = queuertn;
              if (code == 0) {
                if (push[kfunc]) {
                  push[kfunc].map((value, id) => {
                    let dataval = data[value];
                    if (!dataval) dataval = data;
                    if (value.lastIndexOf(".") > -1) {
                      let location = value.replaceAll(".", "/");
                      jptr.set(share, location, dataval);
                    } else {
                      jptr.set(temp, `${name}/${value}`, dataval);
                    }
                  });
                }
              } else {
                if (fnerrs.length > 0) {
                  let fnerr = [];
                  let errmsg = `Current onging step is:${parseInt(idx) + 1
                    }/${workflow.length}. `;
                  if (queuertn.stack) queuertn.stack += errmsg;
                  else if (queuertn.message) queuertn.message += errmsg;
                  fnerrs.map((fn) => {
                    fnerr.push(fn.apply(null, [queuertn, errmsg]));
                  });
                  await Promise.all(fnerr);
                } else if (error != "") {
                  let fnerr = getNestedObject(funcs, error);
                  fnerr.apply(null, [queuertn]);
                }
              }
            }
          }
        }

        if (output.code == 0) {
          output.data = pool;
        }
        resolve(output);
      } catch (error) {
        resolve(errhandler(error));
      }
    });
  };

  const errhandler = (...args) => {
    let [error] = args;
    if (error.errno)
      return {
        code: error.errno,
        errno: error.errno,
        message: error.message,
        stack: error.stack,
        data: error,
      };
    else
      return {
        code: -1,
        errno: -1,
        message: error.message,
        stack: error.stack,
        data: error,
      };
  };

  kernel = {
    utils: {
      sanbox: sanbox,
      getNestedObject: getNestedObject,
      datatype: datatype,
      pick_arrayofobj: pick_arrayofobj,
      pick_arrayobj2list: pick_arrayobj2list,
      omit: omit,
      objpick: objpick,
      arr_selected: arr_selected,
      arr_diffidx: arr_diffidx,
      concatobj: concatobj,
      serialize: serialize,
      errhandler: errhandler,
      handler: {
        get dataformat() {
          return Object.assign(
            {},
            {
              code: 0,
              msg: "",
              data: null,
            }
          );
        },
        get fmtseries() {
          return Object.assign(
            {},
            {
              err: [],
              func: {},
              share: {},
            }
          );
        },
        get wfwseries() {
          return Object.assign(
            {},
            {
              error: "",
              func: "",
              name: "",
              param: [],
              pull: [],
              push: [],
            }
          );
        },
        get winevents() {
          return Object.assign(
            {},
            {
              drag: {
                dragend: {},
                dragenter: {},
                dragleave: {},
                dragover: {},
                dragstart: {},
                drop: {},
              },
              events: {
                change: {},
                input: {},
                load: {},
                resize: {},
                reset: {},
                submit: {},
              },
              focus: {
                blur: {},
                focus: {},
                focusin: {},
                focusout: {},
              },
              mouse: {
                click: {},
                contextmenu: {},
                dbclick: {},
                down: {},
                enter: {},
                leave: {},
                out: {},
                over: {},
                up: {},
              },
            }
          );
        },
      }
    },
  }
  sysmodule = {
    /**
   * The detail refer tohttps://cdn.jsdelivr.net/npm/@sagold/json-pointer@6.0.1/dist/jsonPointer.min.js
   */
    jptr: (() => {
      "use strict";
      var e = {
        d: (t, n) => {
          for (var r in n)
            e.o(n, r) &&
              !e.o(t, r) &&
              Object.defineProperty(t, r, { enumerable: !0, get: n[r] });
        },
        o: (e, t) => Object.prototype.hasOwnProperty.call(e, t),
        r: (e) => {
          "undefined" != typeof Symbol &&
            Symbol.toStringTag &&
            Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
            Object.defineProperty(e, "__esModule", { value: !0 });
        },
      },
        t = {};
      function n(e) {
        return (
          "#" === e || "" === e || (Array.isArray(e) && 0 === e.length) || !1
        );
      }
      e.r(t),
        e.d(t, {
          default: () => _,
          get: () => s,
          isRoot: () => n,
          join: () => P,
          remove: () => v,
          removeUndefinedItems: () => m,
          set: () => g,
          split: () => f,
          splitLast: () => O,
        });
      const r = /~1/g,
        o = /~0/g,
        i = /(^#?\/?)/g;
      function l(e) {
        return e.replace(r, "/").replace(o, "~");
      }
      function u(e) {
        return l(decodeURIComponent(e));
      }
      function f(e) {
        if (null == e || "string" != typeof e || n(e))
          return Array.isArray(e) ? e : [];
        const t = e.indexOf("#") >= 0 ? u : l,
          r = (e = e.replace(i, "")).split("/");
        for (let e = 0, n = r.length; e < n; e += 1) r[e] = t(r[e]);
        return r;
      }
      function s(e, t, r = void 0) {
        if (null == t || null == e) return r;
        if (n(t)) return e;
        const o = c(e, f(t));
        return void 0 === o ? r : o;
      }
      function c(e, t) {
        const n = t.shift();
        if (void 0 !== e) return void 0 !== n ? c(e[n], t) : e;
      }
      const p = /^\[.*\]$/,
        d = /^\[(.+)\]$/;
      function a(e, t) {
        return (
          "__proto__" === e ||
          ("constructor" == e && t.length > 0 && "prototype" == t[0])
        );
      }
      function g(e, t, n) {
        if (null == t) return e;
        const r = f(t);
        if (0 === r.length) return e;
        null == e && (e = p.test(r[0]) ? [] : {});
        let o,
          i,
          l = e;
        for (; r.length > 1;)
          (o = r.shift()), (i = p.test(r[0])), a(o, r) || (l = h(l, o, i));
        return (o = r.pop()), y(l, o, n), e;
      }
      function y(e, t, n) {
        let r;
        const o = t.match(d);
        "[]" === t && Array.isArray(e)
          ? e.push(n)
          : o
            ? ((r = o.pop()), (e[r] = n))
            : (e[t] = n);
      }
      function h(e, t, n) {
        if (null != e[t]) return e[t];
        const r = n ? [] : {};
        return y(e, t, r), r;
      }
      function m(e) {
        let t = 0,
          n = 0;
        for (; t + n < e.length;)
          void 0 === e[t + n] && (n += 1), (e[t] = e[t + n]), (t += 1);
        return (e.length = e.length - n), e;
      }
      function v(e, t, n) {
        const r = f(t),
          o = r.pop(),
          i = s(e, r);
        return i && delete i[o], Array.isArray(i) && !0 !== n && m(i), e;
      }
      const j = /~/g,
        b = /\//g;
      function A(e, t) {
        if (0 === e.length) return t ? "#" : "";
        for (let n = 0, r = e.length; n < r; n += 1)
          (e[n] = e[n].replace(j, "~0").replace(b, "~1")),
            t && (e[n] = encodeURIComponent(e[n]));
        return (t ? "#/" : "/") + e.join("/");
      }
      function P(e, ...t) {
        const n = [];
        if (Array.isArray(e)) return A(e, !0 === arguments[1]);
        const r = arguments[arguments.length - 1],
          o = "boolean" == typeof r ? r : e && "#" === e[0];
        for (let e = 0, t = arguments.length; e < t; e += 1)
          n.push.apply(n, f(arguments[e]));
        const i = [];
        for (let e = 0, t = n.length; e < t; e += 1)
          if (".." === n[e]) {
            if (0 === i.length) return o ? "#" : "";
            i.pop();
          } else i.push(n[e]);
        return A(i, o);
      }
      function O(e) {
        const t = f(e);
        if (0 === t.length)
          return "string" == typeof e && "#" === e[0]
            ? ["#", t[0]]
            : ["", void 0];
        if (1 === t.length) return "#" === e[0] ? ["#", t[0]] : ["", t[0]];
        const n = t.pop();
        return [P(t, "#" === e[0]), n];
      }
      const _ = {
        get: s,
        set: g,
        remove: v,
        join: P,
        split: f,
        splitLast: O,
        isRoot: n,
        removeUndefinedItems: m,
      };
      return t;
    })()
  }


  /**------------------ Private function--------------------------------------------*/
  const initialize = async (...args) => {
    let [param] = args;

    for (let [idx, val] of Object.entries(param)) {
      let func = getNestedObject(glib, idx);
      if (func) {
        let rtn = await sanbox(func, val);
        if (rtn) console.log("Error:", idx, "---", rtn.msg);
      }
    }

    return;
  };

  const loadlib = async (...args) => {
    try {
      let [param] = args;
      for (let item of param) {
        let fn = item.split("/").pop().replace(".js", "");
        fn = fn.replace(".", "-");
        let { default: df, ...otherlib } = await import(item);
        if (Object.keys(otherlib).length > 0) glib[fn] = { ...df, ...otherlib };
        else glib[fn] = df;
      }
      return;
    } catch (error) {
      console.log(error);
    }
  };

  window.addEventListener("DOMContentLoaded", async () => {
    if (mjs) {
      if (mjs.lib.length > 0) await loadlib(mjs.lib);
      if (Object.keys(mjs.initialize).length > 0)
        await initialize(mjs.initialize);
    }
  });
</script>